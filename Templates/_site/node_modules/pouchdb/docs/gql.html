<h1 id='gql_documentation'>GQL Documentation</h1>

<p>The Google Query Language (GQL) interface provides an alternative method for accessing data. The version of GQL implemented here is based on the Google Visualization API Query Language (https://developers.google.com/chart/interactive/docs/querylanguage). The syntax of GQL queries should be familiar to those who have used SQL, but the capabilities of GQL are much more limited.</p>

<p>GQL queries are performed by passing a query object to the gql method along with a callback. Callbacks are in the node.js idiom of <code>function(err, data)</code> Where the first argument will be undefined unless there is an error, and further arguments specify the result. Note that only identifiers and string literals are case-sensitive.</p>

<h3 id='language_syntax'>Language Syntax</h3>

<ul>
<li>
<p><a href='#select'>Select</a></p>
</li>

<li>
<p><a href='#where'>Where</a></p>
</li>

<li>
<p><a href='#groupBy'>Group By</a></p>
</li>

<li>
<p><a href='#pivot'>Pivot</a></p>
</li>

<li>
<p><a href='#label'>Label</a></p>
</li>

<li>
<p><a href='#functions'>Functions</a></p>

<ul>
<li><a href='#aggregation_functions'>Aggregation Functions</a></li>

<li><a href='#scalar_functions'>Scalar Functions</a></li>

<li><a href='#arithmetic_operators'>Arithmetic Operators</a></li>
</ul>
</li>

<li>
<p><a href='#miscellaneous'>Miscellaneous</a></p>

<ul>
<li><a href='#literals'>Literals</a></li>

<li><a href='#identifiers'>Identifiers</a></li>

<li><a href='#reserved_words'>Reserved Words</a></li>
</ul>
</li>
</ul>

<h2 id='perform_a_query'>Perform a Query</h2>

<pre><code>db.gql(query, [options], [callback])</code></pre>

<p>Although only the query is mandatory, the callback is required to access the query result. Currently no query options are implemented.</p>

<pre><code>var pouchdb;
Pouch(&#39;idb://test&#39;, function(err, db) {
   pouchdb = db;
  // Use pouchdb to call further functions
    db.gql({select: &quot;*&quot;, where: &quot;type=&#39;Fire&#39; and name is not null&quot;}, function(err, result){
        if(!err){
        // Use the results of the query here
        }
      }
})</code></pre>

<h2 id='select'>Select</h2>

<pre><code>db.gql({select: &quot;`name!`, price-discount, upper(vendor)&quot;}, callback)</code></pre>

<p>Select returns an object for each document in the database (unless limited by another clause). Each of these objects will be populated with the properties specified in the select clause. Arithmetic operators, aggregation functions, and scalar functions are all fair game. Properties that are missing from an object in the database are assigned null.</p>

<p>With these documents in the database</p>

<pre><code>{name!: &quot;pencil&quot;, price: 2, discount: 0.7, vender: &quot;store1&quot;},
{name!: &quot;pen&quot;, price:3, discount: 2, vendor: &quot;store2&quot;}</code></pre>

<p>The above query will return</p>

<pre><code>{name!: &quot;pen&quot;, price - discount: 1, upper(vendor): &quot;STORE2&quot;},
{name!: &quot;pencil&quot;, price - discount: 1.3, upper(vendor): &quot;STORE1&quot;}</code></pre>

<h2 id='where'>Where</h2>

<pre><code>db.gql({select: &quot;*&quot;, where: &quot;type=&#39;Fire&#39; and name is not null&quot;}, callback)</code></pre>

<p>Where allows filtering of the objects that are passed to the select clause. In this way, unwanted documents can be excluded from the query result. The where clause is composed of conditions which are joined by the logical operators AND and OR. An additional operator, NOT, provides negation.</p>

<p>Comparison operators can be used in conditions to perform comparisons. The supported comparison operators are &lt;=, &lt;, &gt;, &gt;=, !=, and &lt;&gt;. != and &lt;&gt; are equivalent. Null is treated slightly differently; to check if something is null IS NULL is used. To check if something is not null, IS NOT NULL is used.</p>

<p>With these documents in the database</p>

<pre><code>{name: &quot;charmander&quot;, type: &quot;Fire&quot;},
{type: &quot;Fire&quot;, attack:&quot;tail whip&quot;},
{name: &quot;charizard&quot;, type: &quot;Fire&quot;, attack:&quot;slash&quot;}</code></pre>

<p>The above query will return</p>

<pre><code>{_id: &quot;0D715E2C-CEDD-46B4-A060-9C9C290BEBE8&quot;, _rev: &quot;1-71d1e0f8ab00cf432306890a4116602b&quot;,
attack: &quot;slash&quot;, name: &quot;charizard&quot;, type: &quot;Fire&quot;},
{_id: &quot;3153F94B-0568-4D4C-BFA1-83EDF6185915&quot; _rev: &quot;1-d24f7405c5a63943391eaff9a260139c&quot;,
name: &quot;charmander&quot;, type: &quot;Fire&quot;}</code></pre>

<p>Note the inclusion of the _rev and _id fields. This is the result of using &#8216;select *&#8217; instead of naming the desired fields explicitly.</p>

<h2 id='group_by'>Group By</h2>

<pre><code>db.gql({select: &quot;max(charizard), charmeleon&quot;, groupBy: &quot;charmeleon&quot;}, callback)</code></pre>

<p>Group by creates one object for each unique combination of values in the group by clause. For the query above, if every document in the database had the value &#8220;Level 22&#8221; for the property &#8220;charmeleon&#8221;, only a single object would be generated.</p>

<p>If a group by clause is present, every identifier in the select clause must either be the argument of an aggregation function or present in the group by clause. Otherwise, the composite objects formed by the group by clause could have multiple values for some identifiers.</p>

<p>With these documents in the database</p>

<pre><code>{charizard: 50, charmander: 24, charmeleon: 2, haunter:true},
{charizard: 40, charmeleon: 2, charmander: 50},
{charizard: 7, charmeleon: 20, charmander: 15}</code></pre>

<p>The above query will return</p>

<pre><code>{charmeleon: 2, max(charizard): 50}
{charmeleon: 20, max(charizard): 7}</code></pre>

<h2 id='pivot'>Pivot</h2>

<pre><code> db.gql({select: &quot;max(charizard)&quot;, pivot: &quot;charmeleon&quot;}, callback)</code></pre>

<p>Pivot is essentially group by for properties. Each distinct value in the pivot clause gets its own property. Unless used with group by, the result will have only a single document.</p>

<p>The same restriction for group by applies here; every identifier in the select clause must either be the argument of an aggregation function or preset in the group by clause. Additionally, identifiers in the pivot clause may not be used in the group by clause.</p>

<p>Note that using pivot will generate novel property names. See below for an example.</p>

<p>With these documents in the database</p>

<pre><code>{charizard: 50, charmeleon: &quot;hello&quot;},
{charizard: 40, charmeleon: &quot;hello&quot;},
{charizard: 7, charmeleon: &quot;world&quot;, charmander: 15}</code></pre>

<p>The above query will return</p>

<pre><code>{&#39;hello max(charizard)&#39;: 50, &#39;world max(charizard)&#39;: 7}</code></pre>

<h2 id='label'>Label</h2>

<pre><code> db.gql({select: &#39;upper(dept), charizard&#39;,
 label: &quot;upper(dept) &#39;Department&#39;, charizard &#39;Maximum Charizard!&#39;&quot;}, callback)</code></pre>

<p>Label is used to transform cryptic identifiers into something that can be displayed directly to the end user. Items in the label clause can be identifiers, aggregation functions, scalar functions, or operators. The label clause is composed of any number of statement label pairs, where the statement corresponds to some statement in the select clause and the label is a string literal.</p>

<p>With these documents in the database</p>

<pre><code>{charizard: 50, dept: &quot;eng&quot;, lunch:&quot;2&quot;},
{charizard: 40, lunch: &quot;1&quot;, dept: &quot;market&quot;},Â·
{charizard: 99, dept: &quot;eng&quot;, lunch: 1},
{charizard: 7, dept: &quot;eng&quot;, lunch: 2}</code></pre>

<p>The above query will return</p>

<pre><code>{Department: &quot;ENG&quot;, Maximum Charizard!: 7},
{Department: &quot;ENG&quot;, Maximum Charizard!: 99},
{Department: &quot;MARKET&quot;, Maximum Charizard!: 40},
{Department: &quot;ENG&quot;, Maximum Charizard!: 50}</code></pre>

<h2 id='functions'>Functions</h2>

<p>GQL contains a number of operators and functions that can operate on retrived documents.</p>

<h3 id='aggregation_functions'>Aggregation Functions</h3>

<pre><code>db.gql({select: &quot;max(charizard), min(charizard), average(charizard), count(charizard), sum(charizard)&quot;},
callback)</code></pre>

<p>The currently supported aggregation functions are avg, count, max, min, and sum. Each of these takes a single statement as an argument. A statement can be composed of one or more identifiers joined by operators. Avg and sum expect their arguments to evaluate to numbers; the other aggregators will accept any type of input. Aggregation functions operate on entire identifiers, returning only a single property. Aggregation functions may only appear in the select and label clauses.</p>

<p>With these documents in the database</p>

<pre><code>{charizard: 50},
{charizard: 40},
{charizard: 7}</code></pre>

<p>The above query will return</p>

<pre><code>{average(charizard): 32.333333333333336, count(charizard): 3, max(charizard): 50,
min(charizard): 7, sum(charizard): 97}</code></pre>

<h3 id='scalar_functions'>Scalar Functions</h3>

<pre><code>db.gql({select: &quot;`name!`, price-discount, upper(vendor)&quot;}, callback)</code></pre>

<p>Currently only two scalar functions are supported, upper and lower. These change the characters in their inputs to uppercase and lowercase respectively. Unlike aggregator functions, scalar functions take only a single identifier as their input. Scalar functions may only appear in the select and label clauses.</p>

<p>With these documents in the database</p>

<pre><code>{name!: &quot;pencil&quot;, price: 2, discount: 0.7, vender: &quot;store1&quot;},
{name!: &quot;pen&quot;, price:3, discount: 2, vendor: &quot;store2&quot;}</code></pre>

<p>The above query will return</p>

<pre><code>{name!: &quot;pen&quot;, price - discount: 1, upper(vendor): &quot;STORE2&quot;},
{name!: &quot;pencil&quot;, price - discount: 1.3, upper(vendor): &quot;STORE1&quot;}</code></pre>

<h3 id='arithmetic_operators'>Arithmetic Operators</h3>

<pre><code>db.gql({select: &quot;*&quot;, where: &quot;charizard &lt;=charmander * charmeleon + 2 and (charmander - 7 !=  24/3)&quot;},
callback)</code></pre>

<p>Arithmetic operators are used to perform basic math on the values from documents. Their arguments must be numbers. Arithmetic operators may only appear in the select, label, and where clauses. The arguments are implicitly upcast to floats if necessary. The supported arithmetic operators are:</p>

<ul>
<li>Addition: &#8217;+&#8217;</li>

<li>Subtraction: &#8216;-&#8217;</li>

<li>Multiplication: &#8217;*&#8217;</li>

<li>Division: &#8217;/&#8217;</li>
</ul>

<p>With these documents in the database</p>

<pre><code>{charizard: 50, charmander: 24, charmeleon: 2, haunter:true},
{charizard: 40, charmeleon: .5, charmander: 50},
{charizard: 7, charmeleon: 20, charmander: 15}</code></pre>

<p>The above query will return</p>

<pre><code>{charizard: 50, charmander: 24, charmeleon: 2, haunter: true}</code></pre>

<h2 id='miscellaneous'>Miscellaneous</h2>

<p>Some features that are not covered in other sections.</p>

<h3 id='literals'>Literals</h3>

<p>Literals are used for comparison or arithmetic. These are the supported literals:</p>

<ul>
<li>string: Any characters surrounded by single or double quotes</li>

<li>number: Numbers in regular decimal form. They may have a single period, a single negative sign, and no commas</li>

<li>boolean: Either true or false</li>
</ul>

<h3 id='identifiers'>Identifiers</h3>

<p>Identifiers correspond to the properties of documents in the database. There are strict rules governing the way that identifiers can be expressed in queries. If your identifier has spaces, is a reserved word, contains any characters that are not letters or numbers or underscores, or starts with a digit, it must be surrounded by backquotes (`identifier`).</p>

<h3 id='reserved_words'>Reserved Words</h3>

<p>This is the current list of reserved words. Because the GQL implementation is currently under development, this list is likely to grow over time.</p>

<pre><code>and
asc
by
date
datetime
desc
false
format
group
label
limit
not
offset
options
or
order
pivot
select
timeofday
timestamp
true
where</code></pre>